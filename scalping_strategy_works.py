"""
Live Trading System for OANDA
Copyright (c) 2026 Rignesh
Licensed under the MIT License - see LICENSE file for details
"""

# -*- coding: utf-8 -*-
"""scalping_strategy-WORKS

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/156B3_Di1ubZp12HPnU9n8ixQy7X7ao3q
"""

pip install oandapyV20 pandas datetime pytz numpy plotly

import oandapyV20
from oandapyV20.endpoints import instruments, orders
from oandapyV20.contrib.requests import MarketOrderRequest, StopLossDetails, TakeProfitDetails
import pandas as pd
import datetime
import pytz
import time

OANDA_ACCOUNT_ID = ''
OANDA_ACCESS_TOKEN = ''

client = oandapyV20.API(access_token=OANDA_ACCESS_TOKEN)

INSTRUMENT = 'XAU_USD'
UNITS = 3
RISK_REWARD = 2

def fetch_candles_range(instrument, granularity, start, end):
    params = {
        "granularity": granularity,
        "price": "M",
        "from": start.isoformat(),
        "to": end.isoformat()
    }

    r = instruments.InstrumentsCandles(instrument=instrument, params=params)
    client.request(r)

    data = r.response.get("candles", [])

    if not data:
        return pd.DataFrame()

    records = []
    for c in data:
        records.append({
            "t": pd.to_datetime(c["time"]),
            "o": float(c["mid"]["o"]),
            "h": float(c["mid"]["h"]),
            "l": float(c["mid"]["l"]),
            "c": float(c["mid"]["c"]),
            "v": int(c["volume"])
        })

    df = pd.DataFrame(records)

    if df.empty:
        return df

    df.set_index("t", inplace=True)
    return df



def get_opening_range_5m(df_5m):
    session_open = df_5m.index[0].replace(hour=9, minute=30, second=0, microsecond=0)
    opening_candle = df_5m[(df_5m.index >= session_open) & (df_5m.index < session_open + datetime.timedelta(minutes=5))]
    if len(opening_candle) == 0:
        return None, None, None
    candle = opening_candle.iloc[0]
    high = candle['h']
    low = candle['l']
    open_time = opening_candle.index[0]
    return high, low, open_time

def convert_utc_to_est(df):
    df = df.copy()
    df.index = pd.to_datetime(df.index).tz_convert('America/New_York')
    return df

def detect_breakout_retest(df_1m, or_high, or_low, or_start):
    subset = df_1m[df_1m.index > or_start]
    for idx in range(5, len(subset)):
        c = subset.iloc[idx]
        prev5 = subset.iloc[max(0, idx-5):idx]
        if c['c'] > or_high:
            retest = prev5['l'].min() <= or_high * 1.001
            return ("retest_long" if retest else "breakout_long", c.name, "long")
        elif c['c'] < or_low:
            retest = prev5['h'].max() >= or_low * 0.999
            return ("retest_short" if retest else "breakout_short", c.name, "short")
    return (None, None, None)

start = datetime.datetime(2025, 12, 29, tzinfo=datetime.timezone.utc)
end   = datetime.datetime(2025, 12, 31, tzinfo=datetime.timezone.utc)

df_5m = fetch_candles_range("XAU_USD", "M5", start, end)
df_1m = fetch_candles_range("XAU_USD", "M1", start, end)

print(df_1m)

df_5m_est = convert_utc_to_est(df_5m)

df_5m_est.between_time("09:30", "09:34")

"""2 models of entry"""

import numpy as np
import pandas as pd
import datetime
import plotly.graph_objects as go

def _tick_size_for_symbol():
    return 0.01

# main model
def detect_entry_models_wait(
    s_df_after_or,
    or_high,
    or_low,
    skip_first_n=5,
    fvg_lookback=3,
    retest_pct=0.02
):
    out = dict(
        model=None, direction=None,
        entry_time=None, entry_price=None,
        break_time=None, retest_time=None, confirm_time=None
    )

    if s_df_after_or is None or len(s_df_after_or) == 0:
        return out

    s = s_df_after_or.copy().reset_index()
    n = len(s)
    if n <= skip_first_n:
        return out

    i = skip_first_n

    while i < n:

        # state 1: search for breakout
        breakout_idx = None
        direction = None

        while i < n:
            row = s.iloc[i]
            c = row['c']

            if c > or_high:
                breakout_idx = i
                direction = 'long'
                #print(f"[DEBUG] Breakout detected LONG at index {i}, time={s.loc[i,'t']}, close={c}")

                break

            if c < or_low:
                breakout_idx = i
                direction = 'short'
                #print(f"[DEBUG] Breakout detected SHORT at index {i}, time={s.loc[i,'t']}, close={c}")
                break

            i += 1

        if breakout_idx is None:
            return out

        out['break_time'] = s.loc[breakout_idx, 't']
        out['direction'] = direction

        # retest band
        or_range = or_high - or_low
        tol = or_range * retest_pct
        anchor = or_high if direction == 'long' else or_low

        band_low = anchor - tol
        band_high = anchor + tol

        # breakout detected --> wait for retest/validation
        j = breakout_idx + 1
        reentered_or = False
        retest_found = False

        while j < n:
            row = s.iloc[j]
            close_j = row['c']
            low = row['l']
            high = row['h']

            # invalidation logic for entering OR
            if direction == 'short' and close_j > or_low:
                reentered_or = True
                break

            if direction == 'long' and close_j < or_high:
                reentered_or = True
                break


            # retest check
            if direction == 'long':
                entered_zone = (low <= band_high) and (high >= band_low)
            else:
                entered_zone = (high >= band_low) and (low <= band_high)

            if entered_zone:
                retest_found = True
                retest_start_idx = j
                retest_candle = s.iloc[j]

                out['retest_low'] = float(retest_candle['l'])
                out['retest_high'] = float(retest_candle['h'])
                out['retest_time'] = s.loc[j, 't']

                # state 2: retest active --> wait for displacement
                k = j
                while k < n:
                    cur = s.iloc[k]
                    cur_low = cur['l']; cur_high = cur['h']
                    cur_open = cur['o']; cur_close = cur['c']

                    # invalid
                    if direction == 'long' and cur_low < band_low:
                        break
                    if direction == 'short' and cur_high > band_high:
                        break

                    cons_low = float(retest_candle['l']) - tol
                    cons_high = float(retest_candle['h']) + tol

                    if k > retest_start_idx:
                        prev = s.iloc[k - 1]
                        prev_close = prev['c']
                        prev_high = prev['h']
                        prev_low = prev['l']

                        body_size = abs(cur_close - cur_open)
                        full_range = max(cur_high - cur_low, 0.0001)
                        body_ratio = body_size / full_range

                        if direction == 'long':
                            displacement = (
                                cur_close > cons_high and
                                cur_close > prev_close and
                                cur_high > prev_high and
                                body_ratio >= 0.30
                            )

                            if k >= 2:
                                c1 = s.iloc[k - 2]
                                c3 = cur
                                fvg = (c1['h'] < c3['l'])
                                displacement = displacement or fvg

                            if displacement:
                                out['model'] = 1
                                out['confirm_time'] = s.loc[k, 't']
                                out['entry_time'] = out['confirm_time']
                                out['entry_price'] = float(cur_close)
                                return out

                            # wrong-side break
                            if cur_close < cons_low:
                                break

                        else:
                            displacement = (
                                cur_close < cons_low and
                                cur_close < prev_close and
                                cur_low < prev_low and
                                body_ratio >= 0.30
                            )

                            if k >= 2:
                                c1 = s.iloc[k - 2]
                                c3 = cur
                                fvg = (c1['l'] > c3['h'])
                                displacement = displacement or fvg

                            if displacement:
                                out['model'] = 1
                                out['confirm_time'] = s.loc[k, 't']
                                out['entry_time'] = out['confirm_time']
                                out['entry_price'] = float(cur_close)
                                return out

                            if cur_close > cons_high:
                                break

                    k += 1

                # retest failed --> restart from state 0
                i = k + 1
                break

            j += 1

        if reentered_or:
            i = j + 1
            continue

        # MODEL 2
        if not retest_found:
            # search FVG
            for x in range(breakout_idx, n - (fvg_lookback - 1)):
                block = s.iloc[x:x + fvg_lookback]

                if direction == 'long':
                    if float(block.iloc[0]['h']) < float(block.iloc[-1]['l']):
                        fvg_idx = x + (fvg_lookback - 1)
                        out['model'] = 2
                        out['entry_time'] = s.loc[fvg_idx, 't']
                        out['entry_price'] = float(s.loc[fvg_idx, 'c'])
                        return out
                else:
                    if float(block.iloc[0]['l']) > float(block.iloc[-1]['h']):
                        fvg_idx = x + (fvg_lookback - 1)
                        out['model'] = 2
                        out['entry_time'] = s.loc[fvg_idx, 't']
                        out['entry_price'] = float(s.loc[fvg_idx, 'c'])
                        return out

            return out
    return out




# backtester
def backtest_with_two_models_wait(df_5m, df_1m, initial_balance=100000, rr_ratio=2, lots=3,
                                  params=None, verbose=True):
    if params is None:
        params = {
            'skip_first_n': 5,
            'fvg_lookback': 3,
            'retest_pct': 0.05
        }

    tick = _tick_size_for_symbol()

    # timezone convert once
    df_5m_est = convert_utc_to_est(df_5m).tz_localize(None)
    df_1m_est = convert_utc_to_est(df_1m).tz_localize(None)

    balance = initial_balance
    equity_curve = []
    trades = []
    win_count = loss_count = 0

    trading_days = sorted(list(set(df_5m_est.index.normalize())))

    for day in trading_days:
        day_5m = df_5m_est[df_5m_est.index.normalize() == day]
        or_candles = day_5m.between_time("09:30", "09:34")
        if or_candles.empty:
            continue
        or_high = or_candles['h'].max()
        or_low  = or_candles['l'].min()
        or_open_time = or_candles.index[0]
        or_close_time = or_candles.index[-1]

        # 1m data for day
        day_1m = df_1m_est[df_1m_est.index.normalize() == day]
        after_or = day_1m[day_1m.index > or_close_time]
        if after_or.empty:
            continue

        det = detect_entry_models_wait(after_or, or_high, or_low,
                               skip_first_n=params['skip_first_n'],
                               fvg_lookback=params['fvg_lookback'],
                               retest_pct=params['retest_pct'])

        if det.get('entry_time') is None:
            if verbose:
                print(f"{day.date()} | No entry (no retest & no FVG)")
            continue

        # align entry
        try:
            nearest_pos = day_1m.index.get_indexer([det['entry_time']], method='nearest')[0]
        except Exception:
            nearest_pos = 0

        # shift entry to next one minute candle instaed of close
        if nearest_pos + 1 < len(day_1m):
            entry_pos = nearest_pos + 1
        else:
            continue

        entry_time_aligned = day_1m.index[entry_pos]
        entry_price_aligned = float(day_1m.iloc[entry_pos]['o'])

        det['entry_time'] = entry_time_aligned
        det['entry_price'] = entry_price_aligned

        direction = det['direction']
        entry_price = det['entry_price']


        model = det.get("model")

        retest_low_exists  = "retest_low" in det and det["retest_low"]  is not None
        retest_high_exists = "retest_high" in det and det["retest_high"] is not None

        has_retest = retest_low_exists and retest_high_exists

        # 1) MODEL 1 uses STRUCTURE STOP if retest exists
        if model == 1 and has_retest:

            if direction == "long":
                stop = float(det["retest_low"])
                if stop >= entry_price:   # safety fallback
                    stop = entry_price - 0.50
                sl_dist = entry_price - stop
                tp = entry_price + 2 * sl_dist

            else:  # SHORT
                stop = float(det["retest_high"])
                if stop <= entry_price:  # safety fallback
                    stop = entry_price + 0.50
                sl_dist = stop - entry_price
                tp = entry_price - 2 * sl_dist

        # 2) MODEL 2 OR missing retest → ATR FALLBACK
        else:
            atr = day_1m["h"].rolling(14).max() - day_1m["l"].rolling(14).min()
            current_atr = float(atr.loc[det["entry_time"]])
            sl_dist = 0.8 * current_atr

            if direction == "long":
                stop = entry_price - sl_dist
                tp = entry_price + 2 * sl_dist
            else:
                stop = entry_price + sl_dist
                tp = entry_price - 2 * sl_dist



        # ---- CREATE sim_slice (you forgot this) ----
        sim_slice = day_1m[day_1m.index >= det['entry_time']]
        '''
        print(det['entry_time'])
        print(entry_time_aligned)
        print(sim_slice.head(5))
        '''

        if sim_slice.empty:
            continue

        exit_time = None
        exit_price = None
        outcome = None

        for t, r in sim_slice.iterrows():

            if direction == 'long':
                # Check TP first (price going up)
                if r['h'] >= tp:
                    outcome = 'win'; exit_time, exit_price = t, tp
                    break

                # Check SL second (price dipping down)
                if r['l'] <= stop:
                    outcome = 'loss'; exit_time, exit_price = t, stop
                    break

            else:
                # Check TP FIRST (price falling)
                if r['l'] <= tp:
                    outcome = 'win'; exit_time, exit_price = t, tp
                    break

                # Check SL second (price rising)
                if r['h'] >= stop:
                    outcome = 'loss'; exit_time, exit_price = t, stop
                    break


        if outcome is None:
            exit_time = sim_slice.index[-1]
            exit_price = float(sim_slice.iloc[-1]['c'])
            outcome = 'flat'

        pos_size = lots
        pnl = (exit_price - entry_price) * pos_size * 100 if direction == 'long' else (entry_price - exit_price) * pos_size * 100
        balance += pnl
        equity_curve.append(balance)

        trades.append({
            'date': day.date(),
            'model': det.get('model'),
            'direction': direction,
            'entry_time': det.get('entry_time'),
            'entry': entry_price,
            'exit_time': exit_time,
            'exit': exit_price,
            'stop': stop,
            'tp': tp,
            'outcome': outcome,
            'pnl': pnl,
            'balance': balance,
            'break_time': det.get('break_time'),
        })

        if outcome == 'win':
            win_count += 1
        elif outcome == 'loss':
            loss_count += 1

        if verbose:
            print(f"{day.date()} | model:{det.get('model')} | {direction.upper()} | Entry:{entry_price:.2f} | Stop:{stop:.2f} | TP:{tp:.2f} | Outcome:{outcome} | PnL:{pnl:.2f} | Bal:{balance:.2f}")

    # summary
    total_trades = win_count + loss_count
    win_rate = (win_count / total_trades * 100) if total_trades else 0
    profit = balance - initial_balance
    max_dd = (np.max(np.maximum.accumulate(equity_curve) - equity_curve) if equity_curve else 0)
    expectancy = (np.mean([t['pnl'] for t in trades]) if trades else 0)

    print("\n----- SUMMARY -----")
    print(f"Final Balance: {balance:.2f}")
    print(f"Total Trades: {total_trades}")
    print(f"Wins: {win_count} | Losses: {loss_count}")
    print(f"Win Rate: {win_rate:.1f}%")
    print(f"Total Profit: {profit:.2f}")
    print(f"Max Drawdown: {max_dd:.2f}")
    print(f"Expectancy: {expectancy:.2f}")

    return trades, equity_curve


# ---------- Plot ----------
def plot_day_with_models_wait(df_5m, df_1m, trade, params=None):
    """
    Plot a single day using EXACT values from the backtester trade record.
    """

    if params is None:
        params = {
            'skip_first_n': 5,
            'fvg_lookback': 3,
            'retest_pct': 0.10
        }

    # Convert timezone in case
    df_5m_est = convert_utc_to_est(df_5m).tz_localize(None)
    df_1m_est = convert_utc_to_est(df_1m).tz_localize(None)

    day = pd.to_datetime(trade['date']).normalize()

    # 5m data for OR
    day_5m = df_5m_est[df_5m_est.index.normalize() == day]
    or_candles = day_5m.between_time("09:30", "09:34")

    if or_candles.empty:
        print("No OR candles found.")
        return

    # OR high/low
    or_high = or_candles['h'].max()
    or_low  = or_candles['l'].min()
    or_open_time  = or_candles.index[0]
    or_close_time = or_candles.index[-1]

    # 1m candles for the day
    day_1m = df_1m_est[df_1m_est.index.normalize() == day]

    # --------- Start Plotting ----------
    fig = go.Figure()

    fig.add_trace(go.Candlestick(
        x=day_1m.index.to_pydatetime(),
        open=day_1m['o'], high=day_1m['h'],
        low=day_1m['l'], close=day_1m['c'],
        increasing_line_color="#2ECC71",
        decreasing_line_color="#E74C3C",
        name="1m candles"
    ))

    # OR high/low lines
    fig.add_hline(y=or_high, line_color="green", line_width=2, annotation_text="OR High")
    fig.add_hline(y=or_low,  line_color="red",   line_width=2, annotation_text="OR Low")

    # OR block
    fig.add_vrect(
        x0=or_open_time.to_pydatetime(),
        x1=(or_open_time + datetime.timedelta(minutes=5)).to_pydatetime(),
        fillcolor="yellow",
        opacity=0.18,
        line_width=0
    )

    # Session open
    session_open = day.replace(hour=9, minute=30)
    fig.add_vline(x=session_open.to_pydatetime(), line_color="blue")

    entry_time  = trade['entry_time']
    entry_price = float(trade['entry'])
    stop        = float(trade['stop'])
    tp          = float(trade['tp'])
    direction   = trade['direction']
    model       = trade['model']

    if trade.get("break_time") is not None:
      bt = trade["break_time"]
      nearest_idx = day_1m.index.get_indexer([bt], method="nearest")[0]
      bprice = float(day_1m.iloc[nearest_idx]['c'])

      fig.add_trace(go.Scatter(
          x=[bt.to_pydatetime()],
          y=[bprice],
          mode="markers+text",
          marker=dict(size=12, color="orange"),
          text=["BREAK"],
          textposition="bottom center",
          name="breakout"
    ))

    # Entry marker
    fig.add_trace(go.Scatter(
        x=[entry_time.to_pydatetime()],
        y=[entry_price],
        mode="markers+text",
        marker=dict(
            size=14,
            color="magenta" if model == 1 else "cyan",
            symbol="circle"
        ),
        text=[f"ENTRY (Model {model})\n{entry_price:.2f}"],
        textposition="top center",
        name="entry"
    ))

    fig.add_hline(y=stop, line_color="red", line_dash="dash",
                  line_width=2, annotation_text="STOP")

    fig.add_hline(y=tp,   line_color="green", line_dash="dot",
                  line_width=2, annotation_text="TP")

    fig.update_layout(
        title=f"{trade['date']} — OR + Entry (Backtester-Accurate)",
        template="plotly_dark",
        height=820
    )

    fig.show()

trades, equity = backtest_with_two_models_wait(df_5m, df_1m)

trade_1104 = [t for t in trades if t['date'] == datetime.date(2025, 12, 30)][0]
plot_day_with_models_wait(df_5m, df_1m, trade_1104)

"""# **ANALYSIS FUNCTIONS**"""

def run_random_triplet_tests(
    instrument="XAU_USD",
    total_samples=10,
    window_days=3,
    initial_balance=100000,
    lots=3,
    rr_ratio=2,
    verbose=False
):
    import random

    all_trades = []
    combined_equity = [initial_balance]
    balance = initial_balance

    # ---------------------------
    # Generate date list (no fetch)
    # ---------------------------
    print("Building date index...")
    dates = pd.date_range(start="2024-01-01", end="2024-12-31", freq="D")
    max_index = len(dates) - window_days

    print("Running random windows...")

    for i in range(total_samples):

        # --------------------------------------------------
        # Pick a random 3-day window
        # --------------------------------------------------
        idx = random.randint(0, max_index)
        day_start = dates[idx]
        day_end   = dates[idx + window_days - 1]

        # Correct UTC boundaries
        start_utc = datetime.datetime(
            day_start.year, day_start.month, day_start.day,
            0, 0, 0, tzinfo=datetime.timezone.utc
        )
        end_utc = datetime.datetime(
            day_end.year, day_end.month, day_end.day,
            23, 59, 59, tzinfo=datetime.timezone.utc
        )

        # Fetch candles for these 3 days
        df_5m = fetch_candles_range(instrument, "M5", start_utc, end_utc)
        df_1m = fetch_candles_range(instrument, "M1", start_utc, end_utc)

        # --------------------------------------------------
        # Run backtest normally first
        # --------------------------------------------------
        trades_here, eq_here = backtest_with_two_models_wait(
            df_5m, df_1m,
            initial_balance=balance,
            rr_ratio=rr_ratio,
            lots=lots,
            verbose=verbose
        )

        # --------------------------------------------------
        # --------------------------------------------------
        # Now apply REALISTIC CONDITIONS to each trade
        # --------------------------------------------------
        final_trades = []

        for tr in trades_here:

            direction = tr["direction"]
            entry     = float(tr["entry"])
            stop      = float(tr["stop"])
            tp        = float(tr["tp"])

            # ----------------------
            # 1. Spread (fair & small)
            # ----------------------
            spread = 0.25  # $0.25 typical on gold
            if direction == "long":
                entry += spread
                stop  -= spread * 0.4
                tp    -= spread * 0.4
            else:
                entry -= spread
                stop  += spread * 0.4
                tp    += spread * 0.4

            # ----------------------
            # 2. Slippage (moderate)
            # ----------------------
            slippage = random.uniform(-0.20, 0.20)
            entry += slippage * 0.6    # 60% on entry
            stop  -= slippage * 0.2    # 20% on SL
            tp    -= slippage * 0.2    # 20% on TP

            # ----------------------
            # 3. MICRO LATENCY (realistic)
            # ----------------------
            latency_slip = random.uniform(-0.10, 0.10)
            entry += latency_slip

            # ----------------------
            # 4. Execution imperfection (small)
            # ----------------------
            imperf = 0.05
            if direction == "long":
                stop -= imperf
                tp   -= imperf
            else:
                stop += imperf
                tp   += imperf

            tr["entry"] = entry
            tr["stop"]  = stop
            tr["tp"]    = tp

            final_trades.append(tr)


        # --------------------------------------------------
        # Combine equity from realistic trades
        # --------------------------------------------------
        if eq_here:
            balance = eq_here[-1]
            combined_equity.append(balance)

        # Add modified trades to final output
        for t in final_trades:
            t["window"] = (str(day_start.date()), str(day_end.date()))
            all_trades.append(t)

        print(f"Completed {i+1}/{total_samples} windows | Balance: {balance:.2f}")

    # ---------------------------
    # Summary
    # ---------------------------
    print("\n========= TOTAL SUMMARY =========")
    print(f"Final Balance: {balance:.2f}")
    print(f"Total Trades: {len(all_trades)}")

    return all_trades, combined_equity, balance

#-------------------------------------
def analyze_results(trades, equity_curve):
    import numpy as np
    import pandas as pd

    if len(trades) == 0:
        print("No trades to analyze.")
        return {}

    df = pd.DataFrame(trades)

    wins = df[df['outcome'] == 'win']
    losses = df[df['outcome'] == 'loss']

    win_rate = len(wins) / len(df) * 100
    loss_rate = len(losses) / len(df) * 100

    avg_win = wins['pnl'].mean() if len(wins) > 0 else 0
    avg_loss = losses['pnl'].mean() if len(losses) > 0 else 0

    expectancy = df['pnl'].mean()

    profit_factor = wins['pnl'].sum() / abs(losses['pnl'].sum()) if len(losses) > 0 else np.inf
    payoff_ratio = abs(avg_win / avg_loss) if avg_loss != 0 else np.inf

    equity_arr = np.array(equity_curve)
    peak = np.maximum.accumulate(equity_arr)
    drawdown = peak - equity_arr
    max_dd = drawdown.max()

    # streaks
    longest_win_streak = 0
    longest_loss_streak = 0
    current_win = current_loss = 0

    for o in df['outcome']:
        if o == 'win':
            current_win += 1
            current_loss = 0
        elif o == 'loss':
            current_loss += 1
            current_win = 0

        longest_win_streak = max(longest_win_streak, current_win)
        longest_loss_streak = max(longest_loss_streak, current_loss)

    # Sharpe ratio
    returns = df['pnl']
    sharpe = returns.mean() / (returns.std() + 1e-9) * np.sqrt(252) if len(returns) > 1 else 0

    summary = {
        "total_trades": len(df),
        "wins": len(wins),
        "losses": len(losses),
        "win_rate": win_rate,
        "loss_rate": loss_rate,
        "avg_win": avg_win,
        "avg_loss": avg_loss,
        "expectancy": expectancy,
        "profit_factor": profit_factor,
        "payoff_ratio": payoff_ratio,
        "max_drawdown": max_dd,
        "longest_win_streak": longest_win_streak,
        "longest_loss_streak": longest_loss_streak,
        "sharpe_ratio": sharpe,
        "final_balance": equity_curve[-1],
        "total_profit": equity_curve[-1] - equity_curve[0]
    }

    print("\n=================== STRATEGY ANALYSIS ===================")
    print(f"Total Trades:       {summary['total_trades']}")
    print(f"Win Rate:           {summary['win_rate']:.2f}%")
    print(f"Loss Rate:          {summary['loss_rate']:.2f}%")
    print(f"Avg Win:            {summary['avg_win']:.2f}")
    print(f"Avg Loss:           {summary['avg_loss']:.2f}")
    print(f"Expectancy:         {summary['expectancy']:.2f}")
    print(f"Profit Factor:      {summary['profit_factor']:.2f}")
    print(f"Payoff Ratio:       {summary['payoff_ratio']:.2f}")
    print(f"Max Drawdown:       {summary['max_drawdown']:.2f}")
    print(f"Longest Win Streak: {summary['longest_win_streak']}")
    print(f"Longest Loss Streak:{summary['longest_loss_streak']}")
    print(f"Sharpe Ratio:       {summary['sharpe_ratio']:.2f}")
    print(f"Final Balance:      {summary['final_balance']:.2f}")
    print(f"Total Profit:       {summary['total_profit']:.2f}")
    print("==========================================================\n")

    return summary

all_trades, equity, final_balance = run_random_triplet_tests(
    instrument="XAU_USD",
    total_samples=50,
    window_days=3,
    initial_balance=100000,
    lots=3,
    rr_ratio=2,
    verbose=False
)

analysis = analyze_results(all_trades, equity)

"""**Monte Carlo**"""

def monte_carlo_robustness(
    trades,
    equity,
    simulations=1000,
    slip_range=0.20,
    tp_uncertainty=0.10,
    sl_uncertainty=0.10,
    jitter_ticks=0.10
):
    import numpy as np
    import pandas as pd
    import random

    if len(trades) == 0:
        print("No trades for Monte Carlo test.")
        return

    df = pd.DataFrame(trades)

    # Extract raw PnL vector
    base_pnls = df['pnl'].values

    results = []
    sharpe_list = []
    dd_list = []

    print("\n============= Monte Carlo Robustness =============")
    print(f"Simulations: {simulations}")

    for s in range(simulations):

        # --- 1. Bootstrapped trade ordering (random reordering)
        sim_pnls = np.random.choice(base_pnls, size=len(base_pnls), replace=True)

        # --- 2. Add random slippage noise
        slip_noise = np.random.uniform(-slip_range, slip_range, size=len(sim_pnls))
        sim_pnls += slip_noise

        # --- 3. Add TP/SL uncertainty
        tp_noise = np.random.uniform(-tp_uncertainty, tp_uncertainty, size=len(sim_pnls))
        sl_noise = np.random.uniform(-sl_uncertainty, sl_uncertainty, size=len(sim_pnls))

        # Pessimistic: negative noise more likely than positive
        sim_pnls += (0.6 * sl_noise + 0.4 * tp_noise)

        # --- 4. Execution jitter (like micro-latency)
        jitter = np.random.uniform(-jitter_ticks, jitter_ticks, size=len(sim_pnls))
        sim_pnls += jitter

        # --- 5. Track equity path
        equity_path = np.cumsum(sim_pnls) + equity[0]

        # --- 6. Compute metrics
        peak = np.maximum.accumulate(equity_path)
        dd = (peak - equity_path).max()

        # Sharpe calculation
        if sim_pnls.std() > 1e-9:
            sharpe = sim_pnls.mean() / sim_pnls.std() * np.sqrt(252)
        else:
            sharpe = 0

        sharpe_list.append(sharpe)
        dd_list.append(dd)
        results.append(equity_path[-1] - equity_path[0])

    # ---------------- SUMMARY -----------------
    results = np.array(results)
    sharpe_list = np.array(sharpe_list)
    dd_list = np.array(dd_list)

    print("\n=========== Monte Carlo Summary ===========")
    print(f"Mean Profit:      {results.mean():.2f}")
    print(f"Median Profit:    {np.median(results):.2f}")
    print(f"1% Worst Profit:  {np.percentile(results, 1):.2f}")
    print(f"5% Worst Profit:  {np.percentile(results, 5):.2f}")
    print(f"95% Best Profit:  {np.percentile(results, 95):.2f}")

    print("\nSharpe Ratio Distribution:")
    print(f"Mean Sharpe:      {sharpe_list.mean():.2f}")
    print(f"Median Sharpe:    {np.median(sharpe_list):.2f}")
    print(f"1% Worst Sharpe:  {np.percentile(sharpe_list, 1):.2f}")
    print(f"5% Worst Sharpe:  {np.percentile(sharpe_list, 5):.2f}")

    print("\nDrawdown Distribution:")
    print(f"Mean Max DD:      {dd_list.mean():.2f}")
    print(f"95% Worst DD:     {np.percentile(dd_list, 95):.2f}")

    print("================================================\n")

    return {
        "profit_dist": results,
        "sharpe_dist": sharpe_list,
        "dd_dist": dd_list,
    }

mc = monte_carlo_robustness(all_trades, equity, simulations=1000)

"""**MONTHLY**"""

import random
def run_consecutive_days(
    instrument="XAU_USD",
    start_date="2024-01-01",
    total_days=30,
    initial_balance=100000,
    lots=3,
    rr_ratio=2,
    verbose=False,
    realism=True          # <-- enable realistic fills
):
    balance = initial_balance
    all_trades = []
    equity_curve = [balance]

    start_dt = pd.to_datetime(start_date)

    print(f"\nRunning {total_days} consecutive trading days starting from {start_dt.date()}...\n")

    for i in range(total_days):

        day = start_dt + pd.Timedelta(days=i)

        day_start_utc = datetime.datetime(day.year, day.month, day.day, 0, 0, 0, tzinfo=datetime.timezone.utc)
        day_end_utc   = datetime.datetime(day.year, day.month, day.day, 23, 59, 59, tzinfo=datetime.timezone.utc)

        print(f"Day {i+1}/{total_days}: {day.date()}")

        df_5m = fetch_candles_range(instrument, "M5", day_start_utc, day_end_utc)
        df_1m = fetch_candles_range(instrument, "M1", day_start_utc, day_end_utc)

        if df_5m.empty or df_1m.empty:
            print("  No data for this day. Skipping.\n")
            continue

        # ----- RUN CLEAN BACKTEST FOR THIS DAY -----
        trades_here, eq_here = backtest_with_two_models_wait(
            df_5m,
            df_1m,
            initial_balance=balance,
            rr_ratio=rr_ratio,
            lots=lots,
            verbose=verbose
        )

        if realism:
            adjusted_trades = []

            for tr in trades_here:

                direction = tr["direction"]
                entry     = float(tr["entry"])
                stop      = float(tr["stop"])
                tp        = float(tr["tp"])

                # Spread
                spread = 0.25
                if direction == "long":
                    entry += spread
                    stop  -= spread * 0.4
                    tp    -= spread * 0.4
                else:
                    entry -= spread
                    stop  += spread * 0.4
                    tp    += spread * 0.4

                # Slippage
                slippage = random.uniform(-0.20, 0.20)
                entry += slippage * 0.6
                stop  -= slippage * 0.2
                tp    -= slippage * 0.2

                # Micro latency
                latency_slip = random.uniform(-0.10, 0.10)
                entry += latency_slip

                # Imperfection
                imperf = 0.05
                if direction == "long":
                    stop -= imperf
                    tp   -= imperf
                else:
                    stop += imperf
                    tp   += imperf

                tr["entry"] = entry
                tr["stop"]  = stop
                tr["tp"]    = tp

                adjusted_trades.append(tr)

            trades_here = adjusted_trades

        # ----- APPLY TRADES TO BALANCE -----
        if trades_here:
            # FINAL TRADE decides balance for that day
            balance = trades_here[-1]["balance"]

        equity_curve.append(balance)

        for t in trades_here:
            t["date"] = str(day.date())
            all_trades.append(t)

        print(f"  End balance: {balance:.2f}\n")

    print("============= FINAL SUMMARY =============")
    print(f"Start Date:  {start_dt.date()}")
    print(f"End Date:    {(start_dt + pd.Timedelta(days=total_days)).date()}")
    print(f"Final Balance: {balance:.2f}")
    print(f"Total Trades:  {len(all_trades)}")
    print("=========================================\n")

    return all_trades, equity_curve, balance

all_trades, equity, final_balance = run_consecutive_days(
    instrument="XAU_USD",
    start_date="2022-08-01",
    total_days=30,
    initial_balance=100000,
    lots=3,
    rr_ratio=2,
    verbose=False
)

"""**YEARLY**"""

def run_full_year(
    instrument="XAU_USD",
    year=2024,
    initial_balance=100000,
    lots=3,
    rr_ratio=2,
    realism=True,
    verbose=False
):
    import calendar

    monthly_results = []
    balance = initial_balance
    equity_curve = [balance]
    all_trades = []

    print(f"\n=========== RUNNING FULL YEAR {year} ===========\n")

    for month in range(1, 13):

        # --- Determine calendar range for the month ---
        month_start = datetime.datetime(year, month, 1)
        days_in_month = calendar.monthrange(year, month)[1]
        month_end = datetime.datetime(year, month, days_in_month)

        print(f"\n===== MONTH {month} ({month_start.date()} → {month_end.date()}) =====")

        # ---- Run consecutive days for THIS MONTH (all calendar days) ----
        trades_month, eq_month, end_balance = run_consecutive_days(
            instrument=instrument,
            start_date=str(month_start.date()),
            total_days=days_in_month,     # Run ALL calendar days
            initial_balance=balance,
            lots=lots,
            rr_ratio=rr_ratio,
            verbose=verbose,
            realism=realism
        )

        # ---- Monthly stats ----
        profit_month = end_balance - balance
        win_rate = (
            len([t for t in trades_month if t["outcome"] == "win"]) /
            max(len(trades_month), 1)
        ) * 100

        monthly_results.append({
            "month": month,
            "start_balance": balance,
            "end_balance": end_balance,
            "profit": profit_month,
            "num_trades": len(trades_month),
            "win_rate": win_rate
        })

        # Save everything
        all_trades.extend(trades_month)
        balance = end_balance
        equity_curve.extend(eq_month)

        print(f"  PROFIT:     {profit_month:.2f}")
        print(f"  WIN RATE:   {win_rate:.2f}%")
        print(f"  NEW BALANCE:{balance:.2f}\n")

    # ---- Final Yearly Summary ----
    total_profit = balance - initial_balance
    avg_monthly_profit = total_profit / 12
    avg_win_rate = sum(m["win_rate"] for m in monthly_results) / 12

    print("\n============== FINAL YEARLY SUMMARY ==============")
    print(f"Start Balance:      {initial_balance:.2f}")
    print(f"End Balance:        {balance:.2f}")
    print(f"Total Profit:       {total_profit:.2f}")
    print(f"Avg Monthly Profit: {avg_monthly_profit:.2f}")
    print(f"Avg Win Rate:       {avg_win_rate:.2f}%")
    print("==================================================\n")

    return monthly_results, all_trades, equity_curve, balance

results_2024, trades_2024, equity_2024, final_balance_2024 = run_full_year(
    instrument="XAU_USD",
    year=2013,
    initial_balance=100000,
    lots=3,
    rr_ratio=2,
    realism=True,
    verbose=False
)

